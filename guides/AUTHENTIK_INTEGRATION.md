# Authentik Integration Guide

Dead Man's Switch supports JWT authentication via [Authentik](https://goauthentik.io/), an open-source identity provider. This guide will walk you through setting up Authentik and configuring Dead Man's Switch to use it for API and UI authentication.

## Overview

When authentication is enabled, all requests (both API and UI) will require a valid JWT token issued by your Authentik instance. The token must be passed in the `Authorization` header using the `Bearer` scheme:

```
Authorization: Bearer <your-jwt-token>
```

### User-Based Access Control

With authentication enabled, each user can only see and manage their own switches. When you create a switch, it's automatically associated with your user account. The following user identifiers are supported (in order of preference):

1. Subject claim (`sub`)
2. Email claim (`email`)
3. Name claim (`name`)

If authentication is disabled, all switches are accessible using the default `admin` user.

## Prerequisites

- Docker and Docker Compose (for running Authentik)
- A Dead Man's Switch instance
- Basic understanding of OAuth2/JWT authentication

## Quick Start with Docker Compose

### Option A: Fully Automated (No Authentik UI Required)

The project includes a blueprint that preconfigures Authentik with an OAuth2 provider, application, and service account user. No manual UI steps needed.

#### 1. Start Authentik

```bash
docker compose -f authentik/docker-compose.yaml up -d
```

The `post_start` lifecycle hook automatically waits for the blueprint to be applied, then fetches the OAuth2 credentials and writes them to `./authentik/dms-credentials.env`.

#### 2. Get the OAuth2 Credentials

Once the services are up, read the credentials file:

```bash
cat ./authentik/dms-credentials.env
```

Or check the container logs:

```bash
docker compose -f authentik/docker-compose.yaml logs authentik 2>&1 | grep -A5 "OAuth2 Configuration"
```

Output will look like:

```
═══════════════════════════════════════════════════════════════
  Authentik OAuth2 Configuration
═══════════════════════════════════════════════════════════════
  Client ID:     <auto-generated>
  Client Secret: <auto-generated>
  Issuer URL:    http://localhost:9000/application/o/dead-mans-switch/
═══════════════════════════════════════════════════════════════

Start dead-mans-switch with:

  go run . server \
    --auth-enabled \
    --auth-issuer-url "http://localhost:9000/application/o/dead-mans-switch/"
```

#### 3. Start Dead Man's Switch

Copy the printed command from the script output:

```bash
go run . server \
  --auth-enabled \
  --auth-issuer-url "http://localhost:9000/application/o/dead-mans-switch/"
```

#### 4. Get a Token and Test

```bash
# Get the client_id and client_secret from the bootstrap script output, then:
curl -X POST http://localhost:9000/application/o/token/ \
  -d grant_type=client_credentials \
  -d client_id=YOUR_CLIENT_ID \
  -d client_secret=YOUR_CLIENT_SECRET

# Use the token:
TOKEN="<access_token from above>"
curl -H "Authorization: Bearer $TOKEN" http://localhost:8080/api/v1/switch
```

#### How It Works

- **Blueprint** ([authentik/blueprints/dead-mans-switch.yaml](authentik/blueprints/dead-mans-switch.yaml)): Mounted into the Authentik container at `/blueprints/custom/`. Authentik automatically discovers and applies it on startup, creating the OAuth2 provider, application, and service account.
- **Bootstrap env vars** (`AUTHENTIK_BOOTSTRAP_PASSWORD`, `AUTHENTIK_BOOTSTRAP_TOKEN`): Skip the initial setup wizard and create an API token for machine access.
- **`post_start` hook**: Docker Compose runs [scripts/authentik-bootstrap.sh](scripts/authentik-bootstrap.sh) inside the Authentik container after it starts. The script waits for the blueprint to be applied, fetches the auto-generated `client_id` and `client_secret`, writes them to `./authentik/dms-credentials.env`, and prints them to the container logs.
- **No host dependencies**: The script uses `python3` (bundled in the Authentik image) for JSON parsing.

### Option B: Manual Setup (via Authentik UI)

If you prefer manual control or need to customize the setup, follow these steps to replicate what the blueprint creates automatically.

#### 1. Set Up Authentik

Use the provided docker-compose file to spin up Authentik:

```bash
docker compose -f authentik/docker-compose.yaml up -d
```

This will start:
- Authentik server on `http://localhost:9000`
- Authentik worker
- PostgreSQL database
- Redis cache

Wait for services to be healthy (approximately 2-3 minutes):

```bash
docker compose -f authentik/docker-compose.yaml ps
```

#### 2. Access Authentik Admin Panel

1. Open `http://localhost:9000` in your browser
2. Log in with default credentials:
   - Username: `akadmin`
   - Password: `deadmanswitch123!`

#### 3. Create an OAuth2/OpenID Provider

1. Navigate to **Applications** → **Providers**
2. Click **Create** → **OAuth2/OpenID Provider**
3. Configure the following:
   - **Name**: `Dead Man's Switch Provider`
   - **Authorization flow**: `default-provider-authorization-implicit-consent`
   - **Invalidation flow**: `default-provider-invalidation-flow`
   - **Client type**: **Public** (required for PKCE browser-based login)
   - **Redirect URIs/Origins (RegEx)**: Add `http://localhost:8080/` with **Strict** matching mode
   - **Signing Key**: `authentik Self-signed Certificate`
   - **Access code validity**: `seconds=600`
   - **Access token validity**: `seconds=86400` (1 day)
   - **Refresh token validity**: `seconds=2592000` (30 days)
4. Under **Advanced protocol settings**:
   - **Scopes**: Select `openid`, `email`, and `profile`
   - **Subject mode**: `Based on the hashed User ID`
   - **Issuer mode**: `Each provider has a different issuer, based on the application slug`
5. Click **Finish**
6. Note the **Client ID** — you'll need this to start the Dead Man's Switch server

#### 4. Create the Application

1. Navigate to **Applications** → **Applications**
2. Click **Create**
3. Configure:
   - **Name**: `Dead Man's Switch`
   - **Slug**: `dead-mans-switch`
   - **Provider**: Select `Dead Man's Switch Provider` (the provider you just created)
   - **Policy engine mode**: `ANY, any policy must match to grant access`
4. Click **Create**

#### 5. Create a Service Account (Optional — for Machine-to-Machine Access)

1. Navigate to **Directory** → **Users**
2. Click **Create Service Account** (or **Create** and set the type)
3. Configure:
   - **Username**: `dms-service-account`
   - **Name**: `Dead Man's Switch Service Account`
   - **Email**: `dms@localhost`
   - **User type**: `Service Account`
   - **Path**: `goauthentik.io/service-accounts`
4. Set the password (e.g., `dead-mans-switch-service-password`)
5. Click **Create**

#### 6. Create an API Token for the Service Account (Optional)

1. Navigate to **Directory** → **Tokens & App passwords**
2. Click **Create**
3. Configure:
   - **Identifier**: `dms-service-token`
   - **User**: Select `dms-service-account`
   - **Intent**: `App password`
   - **Expiring**: Unchecked (non-expiring)
4. Click **Create**

#### 7. Configure Dead Man's Switch

Get the Client ID from the provider you created in Step 3, then start the server:

```bash
dead-mans-switch server \
  --auth-enabled \
  --auth-issuer-url "http://localhost:9000/application/o/dead-mans-switch/" \
  --auth-audience "YOUR_CLIENT_ID"
```

Or using environment variables:

```bash
export DEAD_MANS_SWITCH_AUTH_ENABLED=true
export DEAD_MANS_SWITCH_AUTH_ISSUER_URL="http://localhost:9000/application/o/dead-mans-switch/"
export DEAD_MANS_SWITCH_AUTH_AUDIENCE="YOUR_CLIENT_ID"
dead-mans-switch server
```

> **Note**: The `--auth-audience` should be set to the Client ID from your OAuth2 provider. Since the provider uses a **public** client type, there is no client secret.

#### 8. Test the Integration

**Browser login**: Open `http://localhost:8080` — you'll be redirected to Authentik to sign in via the PKCE flow.

**Machine-to-machine** (if you created a service account): Use the Resource Owner Password Credentials flow to get a token:

```bash
curl -X POST http://localhost:9000/application/o/token/ \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=password&username=dms-service-account&password=dead-mans-switch-service-password&client_id=YOUR_CLIENT_ID"
```

Then use the token:

```bash
TOKEN="<access_token from above>"
curl -H "Authorization: Bearer $TOKEN" http://localhost:8080/api/v1/switch
```

Success response:
```json
[]
```

Failure response (without token or invalid token):
```
HTTP 401 Unauthorized
Missing authorization header
```

## Configuration Reference

### Environment Variables

- `DEAD_MANS_SWITCH_AUTH_ENABLED` - Enable JWT authentication (true/false)
- `DEAD_MANS_SWITCH_AUTH_ISSUER_URL` - Authentik OAuth2 issuer URL
- `DEAD_MANS_SWITCH_AUTH_AUDIENCE` - Expected JWT audience claim (optional)

### CLI Flags

```bash
dead-mans-switch server --help
```

Relevant flags:
- `--auth-enabled` - Enable JWT authentication
- `--auth-issuer-url` - Authentik OAuth2 issuer URL
- `--auth-audience` - Expected JWT audience claim (optional)

### Issuer URL Format

The issuer URL must point to your Authentik OAuth2 provider base path:

```
http://localhost:9000/application/o/SLUG/
```

Where `SLUG` is the slug you set when creating the application (e.g., `dead-mans-switch`).

## Troubleshooting

### "Public key not found for kid"

The server failed to fetch public keys from Authentik's JWKS endpoint. Check:

1. **Issuer URL is correct** - Verify the issuer URL matches your Authentik setup
2. **Network connectivity** - Ensure the server can reach Authentik's JWKS endpoint: `http://your-authentik:9000/application/o/YOUR_APP/`
3. **Authentik is running** - Check that Authentik services are healthy

### "Invalid issuer"

The token issuer doesn't match the configured issuer URL. Verify:

1. The token was generated from the correct Authentik instance
2. The issuer URL in your Dead Man's Switch config matches exactly (trailing slash matters)

### "Invalid audience"

The JWT audience claim doesn't match the configured audience. Either:

1. Ensure the token includes the correct audience claim
2. Remove the `--auth-audience` flag if audience validation isn't needed
3. Check your Authentik OAuth2 provider settings

### "Missing Authorization header"

API requests must include a valid JWT token in the Authorization header:

```
Authorization: Bearer <token>
```

## Production Deployment

### 1. Use External Authentik Instance

Instead of running Authentik in Docker Compose, use an existing managed Authentik service or a standalone Authentik deployment.

### 2. Secure Communications

- Use HTTPS for all communication with Authentik
- Use the `--auth-issuer-url` with HTTPS endpoint
- Store secrets securely (OAuth2 client credentials)

### 3. JWT Token Caching

The server caches public keys from Authentik's JWKS endpoint. If you rotate keys in Authentik, the cache may need to be invalidated. Consider:

- Restarting the server to refresh the key cache
- Implementing key rotation in your operations

### 4. Token Expiration

Tokens are validated including expiration time. Ensure:

- Client systems have synchronized clocks with the Authentik server
- Token expiration times are appropriate for your use case
- Refresh tokens are obtained when needed

## Disabling Authentication

To disable authentication and run without access control:

```bash
dead-mans-switch server
```

Or explicitly:

```bash
dead-mans-switch server --auth-enabled=false
```

## Advanced: Getting Tokens in Your Application

Here's an example in Python to get a token and make an API request:

```python
import requests

# Authentik configuration
AUTHENTIK_URL = "http://localhost:9000"
APP_SLUG = "dead-mans-switch"
CLIENT_ID = "your-client-id"
CLIENT_SECRET = "your-client-secret"

# Get token
token_response = requests.post(
    f"{AUTHENTIK_URL}/application/o/token/",
    data={
        "grant_type": "client_credentials",
        "client_id": CLIENT_ID,
        "client_secret": CLIENT_SECRET,
    }
)
token = token_response.json()["access_token"]

# Make API request
headers = {"Authorization": f"Bearer {token}"}
response = requests.get("http://localhost:8080/api/v1/switch", headers=headers)
print(response.json())
```

## References

- [Authentik Documentation](https://docs.goauthentik.io/)
- [OAuth 2.0 Specification](https://tools.ietf.org/html/rfc6749)
- [JWT Specification](https://tools.ietf.org/html/rfc7519)

